
!***********************************************************************
!   Portions of Models-3/CMAQ software were developed or based on      *
!   information from various groups: Federal Government employees,     *
!   contractors working on a United States Government contract, and    *
!   non-Federal sources (including research institutions).  These      *
!   research institutions have given the Government permission to      *
!   use, prepare derivative works, and distribute copies of their      *
!   work in Models-3/CMAQ to the public and to permit others to do     *
!   so.  EPA therefore grants similar permissions for use of the       *
!   Models-3/CMAQ software, but users are requested to provide copies  *
!   of derivative works to the Government without restrictions as to   *
!   use by others.  Users are responsible for acquiring their own      *
!   copies of commercial software associated with Models-3/CMAQ and    *
!   for complying with vendor requirements.  Software copyrights by    *
!   the MCNC Environmental Modeling Center are used with their         *
!   permissions subject to the above restrictions.                     *
!***********************************************************************

! RCS file, release, date & time of last delta, author, state, [and locker]
! $Header: /project/work/rep/MCIP2/src/mcip2/gridout.F,v 1.4 2005/08/29 14:31:54 tlotte Exp $ 


SUBROUTINE gridout (sdate, stime)

!-------------------------------------------------------------------------------
! Name:     Grid Out
! Purpose:  Fill arrays for GRID files and outputs.
!             GRID_DOT_2D     GRID_CRO_2D     GRID_CRO_3D
! Revised:  27 Jan 1997  Created for MCIP and generalized CTM.  (D. Byun)
!           04 Feb 1998  LSM method for nonglobal variables changed. (???)
!           30 Apr 1999  PSTAR0 is replaced with PRSFC0 and MAXK.  (D. Byun)
!           20 Sep 2001  Converted to free-form f90.  Added interface for
!                        COLLAPX and removed WORKC.  Added interface for
!                        SANITY and removed NCELLS.  Removed ISTAT from
!                        argument list.  Changed DUMARAY0 and DUMARAY1 to
!                        allocatable.  Removed NLAYS from argument lists
!                        for COMHEADER and COLLAPX.  Changed calling arguments
!                        for COLLAPX.  (T. Otte)
!           20 Nov 2001  Removed "sanity" checks.  (T. Otte)
!           23 Jan 2002  Changed "stop" statements to calls to "m3exit" for
!                        graceful shut-down of I/O API files.  Added logic
!                        to enable "missing" variables in output to have
!                        values of BADVAL3 < AMISS3.  (T. Otte)
!           09 Jun 2003  Removed extraneous variables from output.  Also,
!                        removed unused files GRIDBDY2D and GRIDBDY3D from
!                        output.  (T. Otte)
!           08 Jul 2004  Restored GRIDBDY2D file to output.  Changed local
!                        array allocation to occur only on initial call to
!                        subroutine to avoid memory fragmentation.  (T. Otte)
!           29 Nov 2004  Added PURB.  (T. Otte)
!           25 Feb 2005  Changed names of output file variables by removing
!                        "_G1".  Eliminated GRIDCRO3D for hydrostatic runs.
!                        (T. Otte)
!           19 Aug 2005  Changed internal variable INDEX to IDX to avoid
!                        confusion with F90 intrinsic function.  Modified call
!                        to COLLAPX to reflect that there is one option for
!                        layer collapsing.  (T. Otte)
!-------------------------------------------------------------------------------

  USE mcipparm
  USE xvars
  USE coord
  USE fdesc3
  USE file
  USE iodecl3
  USE lradmdat
  USE groutcom
  USE vgrd
  USE parms3

  IMPLICIT NONE

  INTEGER                      :: c
  INTEGER                      :: col
  REAL,    SAVE, ALLOCATABLE   :: dumaray0    ( : , : , : , : )
  REAL,    SAVE, ALLOCATABLE   :: dumaray1    ( : , : , : , : )
  INTEGER                      :: idx
  CHARACTER*63                 :: ifmt1
  INTEGER                      :: k
  INTEGER                      :: k1
  INTEGER                      :: k2
  INTEGER                      :: l
  INTEGER                      :: lbnd
  INTEGER                      :: lvl
  INTEGER                      :: n
  CHARACTER*16,  PARAMETER     :: pname       = 'GRIDOUT'
  INTEGER                      :: r
  INTEGER                      :: row
  INTEGER,       INTENT(IN)    :: sdate
  INTEGER,       INTENT(IN)    :: stime
  CHARACTER*2                  :: str1
  CHARACTER*2                  :: str2
  REAL                         :: xmapmin
  REAL(8)                      :: xorigdot
  REAL(8)                      :: yorigdot

  INTERFACE

    SUBROUTINE collapx (aa, vertin, vertout)
      IMPLICIT NONE
      REAL,          INTENT(INOUT) :: aa         ( : , : , : )
      REAL,          INTENT(IN)    :: vertin     ( : )
      REAL,          INTENT(IN)    :: vertout    ( : )
    END SUBROUTINE collapx

  END INTERFACE
 
!-------------------------------------------------------------------------------
! Build common header for I/O API files.
!-------------------------------------------------------------------------------

  CALL comheader (sdate, stime)

!-------------------------------------------------------------------------------
! Compute XORIGDOT and YORIGDOT.  Assume (XORIG_GD, YORIG_GD) are
! for cross cells without boundary.
!-------------------------------------------------------------------------------

  lbnd = LBOUND(x3jacobf,3)

  xorigdot = xorig_gd - (0.5 * xcell3d)
  yorigdot = yorig_gd - (0.5 * ycell3d)

!-------------------------------------------------------------------------------
! Build rest of header for GRID_DOT_2D file.
!-------------------------------------------------------------------------------

  DO idx = 1, gd2index
    vtype3d(idx) = m3real
    vname3d(idx) = gd2vname(idx)
    units3d(idx) = gd2units(idx)
    vdesc3d(idx) = gd2vdesc(idx)
  ENDDO

  gdnam3d = TRIM(pname) // '_' // TRIM(grdnam) // '_DOT'

  xorig3d = xorigdot
  yorig3d = yorigdot
  ncols3d = ncols + 1
  nrows3d = nrows + 1
  nthik3d = MAX (nthik, nthikd)

  ftype3d = grdded3
  nvars3d = gd2index
  nlays3d = 1
  tstep3d = 0

  ! Write GRID_DOT_2D header.

  IF ( .NOT. open3 (griddot2d, fsunkn3, pname) ) THEN
    WRITE (6,9000) TRIM(griddot2d)
    GOTO 1001
  ENDIF

!-------------------------------------------------------------------------------
! Build rest of header for GRID_CRO_2D file.
!-------------------------------------------------------------------------------

  DO idx = 1, gc2index
    vtype3d(idx) = m3real
    vname3d(idx) = gc2vname(idx)
    units3d(idx) = gc2units(idx)
    vdesc3d(idx) = gc2vdesc(idx)
  ENDDO

  gdnam3d = TRIM(pname) // '_' // TRIM(grdnam) // '_CROSS'

  xorig3d = xorig_gd
  yorig3d = yorig_gd
  ncols3d = ncols
  nrows3d = nrows

  ftype3d = grdded3
  nvars3d = gc2index
  nlays3d = 1
  tstep3d = 0

  IF ( iflufrc ) THEN
    idx     = gc2index + 1
    nvars3d = idx
    vtype3d(idx) = m3real
    vname3d(idx) = 'PURB'
    units3d(idx) = 'PERCENT'
    vdesc3d(idx) = 'urban percent of cell based on land'  
  ENDIF

  ! Write GRID_CRO_2D header.

  IF ( .NOT. open3 (gridcro2d, fsunkn3, pname) ) THEN
    WRITE (6,9000) TRIM(gridcro2d)
    GOTO 1001
  ENDIF

!-------------------------------------------------------------------------------
! Build rest of header for GRID_BDY_2D file.  Header information is the
! same as GRID_CRO_2D except for file type.
!-------------------------------------------------------------------------------

  ftype3d = bndary3
  nvars3d = gb2index
  nlays3d = 1
  tstep3d = 0

  ! Write GRID_BDY_2D header.

  IF ( .NOT. open3 (gridbdy2d, fsunkn3, pname) ) THEN
    WRITE (6,9000) TRIM(gridbdy2d)
    GOTO 1001
  ENDIF

!-------------------------------------------------------------------------------
! If the file is required, build rest of header for GRID_CRO_3D file.
!-------------------------------------------------------------------------------

  IF ( vgtyp3d /= vgsgph3 ) THEN  ! NOT hydrostatic

    DO idx = 1, gc3index
      vtype3d(idx) = m3real
      vname3d(idx) = gc3vname(idx)
      units3d(idx) = gc3units(idx)
      vdesc3d(idx) = gc3vdesc(idx)
    ENDDO

    gdnam3d = TRIM(pname) // '_' // TRIM(grdnam) // '_CROSS'

    xorig3d = xorig_gd
    yorig3d = yorig_gd
    ncols3d = ncols
    nrows3d = nrows

    ftype3d = grdded3
    nvars3d = gc3index
    nlays3d = nlays
    tstep3d = 0

    ! Write GRID_CRO_3D header.

    IF ( .NOT. open3 (gridcro3d, fsunkn3, pname) ) THEN
      WRITE (6,9000) TRIM(gridcro3d)
      GOTO 1001
    ENDIF

  ENDIF

!-------------------------------------------------------------------------------
! Assign arrays in GRID_DOT_2D (time independent).
!-------------------------------------------------------------------------------

  xmapmin = MINVAL(xmapd)   ! XMAPMIN gets "recycled" below for XMAPC

  DO row = 1, nrows+1
    r = row + nthik
    DO col = 1, ncols+1
      c = col + nthik
      glat_d   (col,row) = xlatd (c,r)
      glon_d   (col,row) = xlond (c,r)

      IF ( xmapmin < amiss3 ) THEN  ! BADVAL3 < AMISS3
        gmsfsq_d (col,row) = badval3
      ELSE
        gmsfsq_d (col,row) = xmapd (c,r)**2
      ENDIF

    ENDDO
  ENDDO

!-------------------------------------------------------------------------------
! Assign arrays in GRID_CRO_2D (time independent).
!-------------------------------------------------------------------------------

  xmapmin = MINVAL(xmapc)  ! XMAPMIN previously defined for XMAPD

  DO row = 1, nrows
    r = row + nthik
    DO col = 1, ncols
      c = col + nthik
            
      glat_c   (col,row) = xlatc   (c,r)
      glon_c   (col,row) = xlonc   (c,r)

      IF ( xmapmin < amiss3 ) THEN  ! BADVAL3 < AMISS3
        gmsfsq_c (col,row) = badval3
      ELSE
        gmsfsq_c (col,row) = xmapc (c,r)**2
      ENDIF

      gtopo_c  (col,row) = xtopo   (c,r)
      gdluse_c (col,row) = xdluse  (c,r)

      IF ( iflufrc ) THEN
        gpurb_c  (col,row) = xpurb   (c,r)
      ENDIF

    ENDDO
  ENDDO

!-------------------------------------------------------------------------------
! Assign arrays in GRID_BDY_2D (time independent).
!-------------------------------------------------------------------------------

  idx = 0
  DO r = 1, nthikd
    DO c = 1 + nthik, ncols_x

      idx = idx + 1

      glat_b   (idx) = xlatc   (c,r)
      glon_b   (idx) = xlonc   (c,r)

      IF ( xmapmin < amiss3 ) THEN  ! BADVAL3 < AMISS3
        gmsfsq_b (idx) = badval3
      ELSE
        gmsfsq_b (idx) = xmapc (c,r)**2
      ENDIF

      gtopo_b  (idx) = xtopo   (c,r)
      gdluse_b (idx) = xdluse  (c,r)

      IF ( iflufrc ) THEN
        gpurb_b  (idx) = xpurb   (c,r)
      ENDIF

    ENDDO
  ENDDO

  ! Side I: add one more index at the end
  ! for NTHIK=0, march 1 more position

  IF ( nthik == 0 ) idx = idx + 1 
      
  DO r = 1+nthik, nrows_x
    DO l = 1, nthikd

      c = ncols_x - nthikd + l
      idx = idx + 1

      glat_b   (idx) = xlatc   (c,r)
      glon_b   (idx) = xlonc   (c,r)

      IF ( xmapmin < amiss3 ) THEN  ! BADVAL3 < AMISS3
        gmsfsq_b (idx) = badval3
      ELSE
        gmsfsq_b (idx) = xmapc (c,r)**2
      ENDIF

      gtopo_b  (idx) = xtopo   (c,r)
      gdluse_b (idx) = xdluse  (c,r)

      IF ( iflufrc ) THEN
        gpurb_b  (idx) = xpurb   (c,r)
      ENDIF

    ENDDO
  ENDDO

  ! Side II: add one more index at the end
  ! for NTHIK=0, march 1 more position

  IF ( nthik == 0 ) idx = idx + 1 
      
  ! Side III: add one more index before
  ! for NTHIK=0, march 1 more position

  IF ( nthik == 0 ) idx = idx + 1 

  DO l = 1, nthikd
    r = nrows_x - nthikd + l
    DO c = 1, ncols_x - nthik
      idx = idx + 1

      glat_b   (idx) = xlatc   (c,r)
      glon_b   (idx) = xlonc   (c,r)

      IF ( xmapmin < amiss3 ) THEN  ! BADVAL3 < AMISS3
        gmsfsq_b (idx) = badval3
      ELSE
        gmsfsq_b (idx) = xmapc (c,r)**2
      ENDIF

      gtopo_b  (idx) = xtopo   (c,r)
      gdluse_b (idx) = xdluse  (c,r)

      IF ( iflufrc ) THEN
        gpurb_b  (idx) = xpurb   (c,r)
      ENDIF

    ENDDO
  ENDDO
      
  ! Side IV: add one more index before
  ! for NTHIK=0, march 1 more position

  IF ( nthik == 0 ) idx = idx + 1 

  DO r = 1, nrows_x - nthik
    DO c = 1, nthikd

      idx = idx + 1

      glat_b   (idx) = xlatc   (c,r)
      glon_b   (idx) = xlonc   (c,r)

      IF ( xmapmin < amiss3 ) THEN  ! BADVAL3 < AMISS3
        gmsfsq_b (idx) = badval3
      ELSE
        gmsfsq_b (idx) = xmapc (c,r)**2
      ENDIF

      gtopo_b  (idx) = xtopo   (c,r)
      gdluse_b (idx) = xdluse  (c,r)

      IF ( iflufrc ) THEN
        gpurb_b  (idx) = xpurb   (c,r)
      ENDIF

    ENDDO
  ENDDO

!-------------------------------------------------------------------------------
! Collapse 3-D 'X' arrays.  (Original values are replaced.)
! For safe collpasing, store information first in DUMARRAY.
!   IMODE = 1 : weighted layer averaging
!   IMODE = 2 : selective layer collection
!-------------------------------------------------------------------------------

  IF ( vgtyp3d /= vgsgph3 ) THEN  ! NOT hydrostatic

    IF ( metlay /= nlays ) THEN

      IF ( .NOT. ALLOCATED ( dumaray0 ) )  &
        ALLOCATE ( dumaray0 ( ncols_x, nrows_x, 0:metlay, 1 ) )
      IF ( .NOT. ALLOCATED ( dumaray1 ) )  &
        ALLOCATE ( dumaray1 ( ncols_x, nrows_x, 1:metlay, 1 ) )

      DO k = 1, metlay
        DO r = 1, nrows_x
          DO c = 1, ncols_x
            dumaray1(c,r,k,1) = x3htm(c,r,k)
          ENDDO 
        ENDDO
      ENDDO

      DO k = 0, metlay
        DO r = 1, nrows_x
          DO c = 1, ncols_x
            dumaray0(c,r,k,1) = x3htf(c,r,k)
          ENDDO 
        ENDDO
      ENDDO    

      CALL collapx (x3htm, xx3midl, x3midl)
      CALL collapx (x3htf, xx3face, x3face)

    ENDIF  

!-------------------------------------------------------------------------------
! If the file is required, assign arrays in GRID_CRO_3D (time independent).  
!-------------------------------------------------------------------------------

    DO row = 1, nrows
      r = row + nthik
      DO col = 1, ncols
        c = col + nthik
        DO lvl = 1, nlays
          k = lvl

          gx3htf_c (col,row,lvl) = x3htf (c,r,k)
          gx3htm_c (col,row,lvl) = x3htm (c,r,k)
 
        ENDDO
      ENDDO
    ENDDO

  ENDIF  ! NOT hydrostatic

!-------------------------------------------------------------------------------
! Write GRID_DOT_2D data (time independent data).
! Read FDESC3 from GRIDDOT2D to get header information.
!-------------------------------------------------------------------------------

  IF ( .NOT. desc3 (griddot2d) ) THEN
    CALL m3err ('GRIDOUT', sdate, stime,  &
                'Could not read DESC of ' // griddot2d // ' file', .TRUE.)
  ENDIF

  IF ( .NOT. write3 (griddot2d, allvar3, sdate, stime, gd2) ) THEN
    WRITE (6,9100) TRIM(griddot2d)
    GOTO 1001
  ENDIF

!-------------------------------------------------------------------------------
! Write GRID_CRO_2D data (time independent data).
!-------------------------------------------------------------------------------

  IF ( .NOT. desc3 (gridcro2d) ) THEN
    CALL m3err ('GRIDOUT', sdate, stime,  &
                'Could not read DESC of ' // gridcro2d // ' file', .TRUE.)
  ENDIF

  DO l = 1, gc2index
    IF ( .NOT. write3 (gridcro2d, vname3d(l), sdate, stime,  &
                       gc2(1,1,l)) ) THEN
      WRITE (6,9100) TRIM(gridcro2d)
      GOTO 1001
    ENDIF
  ENDDO

  IF ( iflufrc ) THEN
    IF ( .NOT. write3 (gridcro2d, vname3d(gc2index+1), sdate, stime,  &
                       gc2(1,1,gc2index+1)) ) THEN
      WRITE (6,9100) TRIM(gridcro2d)
      GOTO 1001
    ENDIF
  ENDIF

!-------------------------------------------------------------------------------
! Write GRID_BDY_2D data (time independent data).
!-------------------------------------------------------------------------------

  IF ( .NOT. desc3 (gridbdy2d) ) THEN
    CALL m3err ('GRIDOUT', sdate, stime,  &
                'Could not read DESC of ' // gridbdy2d // ' file', .TRUE.)
  ENDIF

  IF ( .NOT. write3 (gridbdy2d, allvar3, sdate, stime, gb2) ) THEN
    WRITE (6,9100) TRIM(gridbdy2d)
    GOTO 1001
  ENDIF

!-------------------------------------------------------------------------------
! If the file is required, write GRID_CRO_3D data (time independent data).
!-------------------------------------------------------------------------------

  IF ( vgtyp3d /= vgsgph3 ) THEN  ! NOT hydrostatic

    IF ( .NOT. desc3 (gridcro3d) ) THEN
      CALL m3err ('GRIDOUT', sdate, stime,  &
                  'Could not read DESC of ' // gridcro3d // ' file', .TRUE.)
    ENDIF

    IF ( .NOT. write3 (gridcro3d, allvar3, sdate, stime, gc3) ) THEN
      WRITE (6,9100) TRIM(gridcro3d)
      GOTO 1001
    ENDIF

!-------------------------------------------------------------------------------
! For safe collpasing, restore information from DUMARRAY.
!-------------------------------------------------------------------------------

    IF ( metlay /= nlays ) THEN

      DO k = 1, metlay
        DO r = 1, nrows_x
          DO c = 1, ncols_x
            x3htm(c,r,k) = dumaray1(c,r,k,1)
          ENDDO 
        ENDDO
      ENDDO

      DO k = 0, metlay
        DO r = 1, nrows_x
          DO c = 1, ncols_x
            x3htf(c,r,k) = dumaray0(c,r,k,1) 
          ENDDO 
        ENDDO
      ENDDO 

!     DEALLOCATE ( dumaray0 )  ! commented out to avoid memory fragmentation
!     DEALLOCATE ( dumaray1 )  ! commented out to avoid memory fragmentation

    ENDIF   

!-------------------------------------------------------------------------------
! Print sample output to log file.
!-------------------------------------------------------------------------------

    k1 = nlays / 5
    k2 = MOD(nlays, 5)

    WRITE ( str1, '(i2)' ) k1 - 1
    WRITE ( str2, '(i2)' ) k2

    IF ( (k1 - 1) > 0 ) THEN
      IF ( k2 > 0 ) THEN
        ifmt1 = "(/,1x,a9,5(2x,f12.4)," // str1 // "(/,10x,5(2x,f12.4)),/,10x," &
           &    // str2 // "(2x,f12.4))"
      ELSE
        ifmt1 = "(/,1x,a9,5(2x,f12.4)," // str1 // "(/,10x,5(2x,f12.4)))"
      ENDIF
    ELSE
      IF ( k2 > 0 ) THEN
        ifmt1 = "(/,1x,a9,5(2x,f12.4),/,10x," // str2 // "(2x,f12.4))"
      ELSE
        ifmt1 = "(/,1x,a9,5(2x,f12.4))"
      ENDIF
    ENDIF

  ENDIF  ! NOT hydrostatic

  WRITE (*,'(/,a,/)') '- GRIDOUT: Printing sample cells in output grid'

  DO n = 1, gc2index
    WRITE (*,6000) TRIM(gc2vname(n)), gc2(lprt_col,lprt_row,n), gc2units(n)
  ENDDO

  DO n = 1, gd2index
    WRITE (*,6000) TRIM(gd2vname(n)), gd2(lprt_col,lprt_row,n), gd2units(n)
  ENDDO

  IF ( vgtyp3d /= vgsgph3 ) THEN  ! NOT hydrostatic
    DO n = 1, gc3index
      WRITE (*,ifmt1) TRIM(gc3vname(n)), gc3(lprt_col,lprt_row,:,n)
    ENDDO
  ENDIF

  RETURN

!-------------------------------------------------------------------------------
! Format statements.
!-------------------------------------------------------------------------------

 6000 FORMAT (1x, a9, 2x, f12.4, 2x, a)

!-------------------------------------------------------------------------------
! Error-handling section.
!-------------------------------------------------------------------------------

 9000 FORMAT (/, 1x, 70('*'),                                              &
              /, 1x, '*** SUBROUTINE: GRIDOUT',                            &
              /, 1x, '***   ERROR OPENING FILE ', a,                       &
              /, 1x, 70('*'))

 9100 FORMAT (/, 1x, 70('*'),                                              &
              /, 1x, '*** SUBROUTINE: GRIDOUT',                            &
              /, 1x, '***   ERROR WRITING TO FILE ', a,                    &
              /, 1x, 70('*'))

 1001 CALL graceful_stop (pname)
      RETURN

END SUBROUTINE gridout
