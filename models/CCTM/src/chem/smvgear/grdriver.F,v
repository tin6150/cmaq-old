head     1.1;
branch   1.1.1;
access   ;
symbols  CMAQv4_5_1:1.1.1.1 ASMD:1.1.1;
locks    ; strict;
comment  @c @;


1.1
date     2006.03.15.20.43.48;  author sjr;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2006.03.15.20.43.48;  author sjr;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@
C***********************************************************************
C   Portions of Models-3/CMAQ software were developed or based on      *
C   information from various groups: Federal Government employees,     *
C   contractors working on a United States Government contract, and    *
C   non-Federal sources (including research institutions).  These      *
C   research institutions have given the Government permission to      *
C   use, prepare derivative works, and distribute copies of their      *
C   work in Models-3/CMAQ to the public and to permit others to do     *
C   so.  EPA therefore grants similar permissions for use of the       *
C   Models-3/CMAQ software, but users are requested to provide copies  *
C   of derivative works to the Government without restrictions as to   *
C   use by others.  Users are responsible for acquiring their own      *
C   copies of commercial software associated with Models-3/CMAQ and    *
C   for complying with vendor requirements.  Software copyrights by    *
C   the MCNC Environmental Modeling Center are used with their         *
C   permissions subject to the above restrictions.                     *
C***********************************************************************

C RCS file, release, date & time of last delta, author, state, [and locker]
C $Header: /project/work/rep/CCTM/src/chem/smvgear/grdriver.F,v 1.13 2005/08/29 18:34:47 sjr Exp $ 

C what(1) key, module and SID; SCCS file; date and time of last delta:
C @@(#)grdriver.F        1.1 /project/mod3/CMAQ/src/chem/smvgear/SCCS/s.grdriver.F 07 Jul 1997 12:45:24

       SUBROUTINE CHEM( CONC, JDATE, JTIME, TSTEP )

C**********************************************************************
C
C  FUNCTION: To control gas phase chemistry calculations performed by
C            the vectorized Gear solver (aka SMVGEAR)
C
C  PRECONDITIONS: None
C
C  KEY SUBROUTINES/FUNCTIONS CALLED: GRINIT
C                                    JSPARSE
C                                    SIGMAFH
C                                    PHOT
C                                    CALCKS
C                                    SMVGEAR
C
C  REVISION HISTORY: Prototype created by Jerry Gipson, June, 1995
C
C                    Revised 3/14/96 by Jerry Gipson to conform to
C                      the Models-3 minimum IOV configuration.
C                    Revised December 1996 by Jerry Gipson to conform
C                      to the Models-3 interim CTM that includes emissions
C                      in chemistry.
C                    Add DTIME performance stats as cpp option (Jeff Dec 96)
C                    Revised April 1997 to distinguish NSPCS from NSPCSD
C                    Revised April 1997 to conform to Models-3 framework
C                    Revised June 1997 to conform to beta version
C                    Modified June, 1997 by Jerry Gipson to be consistent
C                      with beta CTM
C                    Modified September, 1997 by Jerry Gipson to be
C                      consistent with the tartgtted CTM
C                    Modified March, 1998 by Jerry Gipson to read
C                      an emission file with units of moles/s
C                    Mod for unicode by Jeff, Feb. 1999
C                    16 Aug 01 J.Young: dyn alloc - Use HGRD_DEFN; replace
C                      INTERP3 with INTERPX; some allocatable arrays;
C                      Use GRVARS module
C                    31 Jan 05 J.Young: dyn alloc - establish both horizontal
C                    & vertical domain specifications in one module (GRID_CONF)
C                    29 Jul 05     WTH: Added IF blocks that call degrade 
C                                       routines if MECHNAME contains 'TX' 
C                                       substring.
C**********************************************************************

      USE GRVARS              ! inherits GRID_CONF
      USE CGRID_SPCS          ! CGRID species number and offsets

      IMPLICIT NONE 

C..INCLUDES:
!     INCLUDE SUBST_HGRD_ID   ! Horizontal grid data
!     INCLUDE SUBST_VGRD_ID   ! Vertical grid data
!     INCLUDE SUBST_BLKPRM    ! Blockimng parameters
      INCLUDE SUBST_IOPARMS   ! Io/api parameters
      INCLUDE SUBST_IOFDESC   ! Io/api file descriptions
      INCLUDE SUBST_IODECL    ! Io/api declarations
      INCLUDE SUBST_FILES_ID  ! CMAQ files
!     INCLUDE SUBST_COORD_ID  ! Coordinate and domain definitions (req IOPARMS)
      INCLUDE SUBST_CONST     ! CMAQ constants
      INCLUDE SUBST_GC_SPC    ! Gas chem species names and MWs
      INCLUDE SUBST_RXCMMN    ! Mechanism reaction common block
!     INCLUDE SUBST_RXDATA    ! Mechanism reaction data
      INCLUDE SUBST_GC_EMIS   ! Gas chem emissions name and mapping tables
!     INCLUDE SUBST_EMLYRS_ID ! Emissions layers parameter
#ifdef emis_chem
      INCLUDE SUBST_EMPR_CH   ! Emissions processing in chem
#else
      INCLUDE SUBST_EMPR_VD   ! Emissions processing in vdif
#endif
      INCLUDE SUBST_PACTL_ID  ! Process analysis control parameters

      INCLUDE 'GRPARMS.EXT'
      INCLUDE 'GRVARS1.EXT'
      INCLUDE 'GRVARS2.EXT'
      INCLUDE 'GRVARS3.EXT'
      
C..ARGUMENTS:
!     REAL CONC( NCOLS, NROWS, NLAYS, * )  ! Species concentrations
!     REAL      :: CONC( :,:,:,: )  ! concentrations
      REAL, POINTER :: CONC( :,:,:,: )  ! concentrations
      INTEGER JDATE           ! Current date (YYYYDDD)
      INTEGER JTIME           ! Current time (HHMMSS)
      INTEGER TSTEP( 2 )      ! Time step vector (HHMMSS)

C..PARAMETERS:

C Integer zero
      INTEGER, PARAMETER :: IZERO = 0

C Conc. of M = 1E+06 ppm
      REAL, PARAMETER :: CONCOFM = 1.0E+06

C Pascal to atm conversion factor
      REAL, PARAMETER :: PA2ATM = 1.0 / STDATMPA

C..EXTERNAL FUNCTIONS:
      INTEGER INDEX1          ! Looks up name in a list
      INTEGER SEC2TIME        ! Returns time interval from seconds
      INTEGER TIME2SEC        ! Returns seconds in time interval

#ifdef sunws
      REAL     DTIME          ! Execution time elapsed since last call
      EXTERNAL DTIME
#endif

C..SAVED LOCAL VARIABLES:
      LOGICAL, SAVE :: LFIRST = .TRUE. ! Flag for first call to this subroutine
      INTEGER, SAVE :: IRUNC     ! Counter of calls to this subroutine
      INTEGER, SAVE :: LOGDEV    ! Unit number of output log
      INTEGER, SAVE :: NOXYZ     ! Total number of grid cells
      LOGICAL, SAVE :: LIRRBLK   ! Flag to indicate IRR to be done for block
      REAL, SAVE :: AIRFC        ! Factor to convert gms air to ppm
      REAL, SAVE :: MAOMV        ! Mol Wt of air over Mol Wt of water
!     REAL, SAVE :: RELWT( NS_CH )! Emis species mass to molar conversion factor
!     REAL, SAVE :: CONV( NLAYS )   ! Volumetric emissions conversion factors 
      REAL, ALLOCATABLE, SAVE :: CONV( : )
      INTEGER, SAVE :: EMISLYRS     ! number of emission layers from file
      
C..SCRATCH LOCAL VARIABLES:
      CHARACTER( 144 ) :: MSG       ! Message text
      CHARACTER( 16 ) :: PNAME = 'GRDRIVER' ! Routine name
      CHARACTER( 16 ) :: UNITSCK    ! Units description
      CHARACTER( 16 ) :: VNAME      ! Name of I/O API data variable
      CHARACTER( 16 ) :: UC_UNITS   ! Units in upper case

      INTEGER BLK             ! Loop index for block of cells
      INTEGER CELLNUM         ! Cell number 
      INTEGER COL             ! Column index
      INTEGER ESP             ! Loop index for emissions species
      INTEGER IPAR            ! Pointer for cell sort routine
      INTEGER IRVAL           ! Pointer for cell sort routine
      INTEGER IRXN            ! Reaction number
      INTEGER ISP             ! Species index
      INTEGER ISPOLD          ! Species number in original order
      INTEGER ISPNEW          ! Species number in new sorted order 
      INTEGER ITMSTEP         ! Chemistry integration interval (sec)   
      INTEGER JPAR            ! Pointer for cell sort routine
      INTEGER JREORD          ! Index holder for sort routine
      INTEGER LEV             ! Layer index
      INTEGER LVAL            ! Pointer for cell sort routine
      INTEGER MIDDATE         ! Date at time step midpoint
      INTEGER MIDTIME         ! Time at time step midpoint
      INTEGER NCELL           ! Index for number of cells
      INTEGER NDARK           ! Number of layer 1 cells in darkness
      INTEGER NIRRCLS         ! No. of cells in block for IRR
      INTEGER NMID            ! Middle cell number in block
      INTEGER NPH             ! Index for number of phot. rxns in PHOT
      INTEGER NRX             ! Index for number of reactions
      INTEGER ROW             ! Row index
      INTEGER SPC             ! Species loop index
      INTEGER VAR             ! Variable number on I/O API file
!     INTEGER XSTAT0          ! Exit status code
!     INTEGER XSTAT1          ! Exit status code
!     INTEGER XSTAT2          ! Exit status code
      INTEGER IRRCELL(   BLKSIZE ) ! Cell No. of an IRR cell
!     INTEGER IRSPERF(    MXBLKS ) ! Number of restarts at beginning
!     INTEGER MXORDPERF(  MXBLKS ) ! Maximum order used
!     INTEGER NBKUPS(     MXBLKS ) ! Number of backups
!     INTEGER NCFAILPERF( MXBLKS ) ! Number of convergence failures
!     INTEGER NEFAILPERF( MXBLKS ) ! Number of error test failures
!     INTEGER NITERPERF(  MXBLKS ) ! Number of iterations
!     INTEGER NSTPERF(    MXBLKS ) ! Number of steps used
!     INTEGER NPDPERF(    MXBLKS ) ! Number of Jacobian updates
!     INTEGER NSUBPERF(   MXBLKS ) ! Number of RHS evaluations
      INTEGER, ALLOCATABLE :: IRSPERF   ( : ) ! Number of restarts at beginning
      INTEGER, ALLOCATABLE :: MXORDPERF ( : ) ! Maximum order used
      INTEGER, ALLOCATABLE :: NBKUPS    ( : ) ! Number of backups
      INTEGER, ALLOCATABLE :: NCFAILPERF( : ) ! Number of convergence failures
      INTEGER, ALLOCATABLE :: NEFAILPERF( : ) ! Number of error test failures
      INTEGER, ALLOCATABLE :: NITERPERF ( : ) ! Number of iterations
      INTEGER, ALLOCATABLE :: NSTPERF   ( : ) ! Number of steps used
      INTEGER, ALLOCATABLE :: NPDPERF   ( : ) ! Number of Jacobian updates
      INTEGER, ALLOCATABLE :: NSUBPERF  ( : ) ! Number of RHS evaluations
      INTEGER ALLOCSTAT
  
      REAL CHEMSTEP           ! Chemistry integration interval (min)
      REAL CONVEM             ! Emissions conversion factor
      REAL CONVFC             ! Emissions conversion factor
      REAL DX                 ! Cell x-dimension
      REAL DY                 ! Cell  y-dimension
      REAL VALLOW             ! Value holder for sort routine
      
      REAL DENSA_J( NCOLS, NROWS, NLAYS )   ! Cell density (Kg/m**3)
      REAL PRES(    NCOLS, NROWS, NLAYS )   ! Cell pressure (Pa)
      REAL QV(      NCOLS, NROWS, NLAYS )   ! Cell water vapor (Kg/Kg air)
      REAL TA(      NCOLS, NROWS, NLAYS )   ! Cell temperature (K)
      REAL DENS(    NCOLS, NROWS, NLAYS )   ! Cell density (Kg/m^3)

      REAL RJBLK( BLKSIZE, NPHOTAB )        ! J-values for each cell in 
                                            ! a block

      REAL RJ( NCOLS, NROWS, NLAYS, NPHOTAB )  ! J-values for each cell      

      REAL( 8 ) BLKDENS( BLKSIZE )          ! Cell density (Kg/m^3) in block

      REAL CHEMIS( NC_CH, NR_CH, NL_CH, NS_CH )  ! Emissions in each cell

      INTEGER     GXOFF, GYOFF          ! global origin offset from file
C for INTERPX
      INTEGER, SAVE :: STRTCOLMC3, ENDCOLMC3, STRTROWMC3, ENDROWMC3
      INTEGER, SAVE :: STRTCOLEM1, ENDCOLEM1, STRTROWEM1, ENDROWEM1

      REAL( 8 ), ALLOCATABLE, SAVE :: Y_DEGRADE ( : , : ) ! concentration array used
                                                          ! by degradation routines

#ifdef sunws
      REAL    ERRSTAT          ! for DTIME()
      REAL    TARRAY( 2 )      ! for DTIME():TARRAY(1)=user time,
                               ! TARRAY(2)=system time
      REAL    DRIVER_TIME      ! accumulated driver user time for this step
      REAL    SOLVER_TIME      ! accumulated solver user time for this step
#endif

      INTERFACE
!        SUBROUTINE PHOT ( MDATE, MTIME, JDATE, JTIME, NDARK, RJ )
!           IMPLICIT NONE
!           INTEGER, INTENT( IN )  :: MDATE, MTIME, JDATE, JTIME
!           INTEGER, INTENT( OUT ) :: NDARK
!           REAL,    INTENT( OUT ) :: RJ( :,:,:,: )
!        END SUBROUTINE PHOT
         SUBROUTINE PA_IRR_CKBLK ( NUMCELLS, LIRRBLK, OFFSET,
     &                             CCOL, CROW, CLEV, NORDCELL,
     &                             NIRRCLS, IRRCELL )
            IMPLICIT NONE
            INTEGER, INTENT( IN )   :: NUMCELLS, OFFSET
            LOGICAL, INTENT( OUT )  :: LIRRBLK
            INTEGER, INTENT( IN )   :: CCOL( : ), CROW( : ), CLEV( : )
            INTEGER, INTENT( IN )   :: NORDCELL( : )
            INTEGER, INTENT( IN )   :: NIRRCLS
            INTEGER, INTENT( OUT )  :: IRRCELL( : )
         END SUBROUTINE PA_IRR_CKBLK
         SUBROUTINE PA_IRR_BLKENDC ( OFFSET, 
     &                               CCOL, CROW, CLEV, NORDCELL,
     &                               NIRRCLS, IRRCELL )
            IMPLICIT NONE
            INTEGER, INTENT( IN )   :: OFFSET
            INTEGER, INTENT( IN )   :: CCOL( : ), CROW( : ), CLEV( : )
            INTEGER, INTENT( IN )   :: NORDCELL( : )
            INTEGER, INTENT( IN )   :: NIRRCLS
            INTEGER, INTENT( IN )   :: IRRCELL( : )
         END SUBROUTINE PA_IRR_BLKENDC
         SUBROUTINE SMVGEAR ( IRUN, JDATE, JTIME, CHEMSTEP,
     &                        LIRRFLAG, NIRRCLS, IRRCELL )
!           USE HGRD_DEFN
            USE GRID_CONF
            IMPLICIT NONE
            INTEGER, INTENT( IN )   :: IRUN, JDATE, JTIME
            REAL, INTENT( IN )      :: CHEMSTEP
            LOGICAL, INTENT( IN )   :: LIRRFLAG
            INTEGER, INTENT( IN )   :: NIRRCLS
            INTEGER, INTENT( IN )   :: IRRCELL( BLKSIZE )
         END SUBROUTINE SMVGEAR
      END INTERFACE

C**********************************************************************

      IF ( N_GC_SPC.EQ.0 ) RETURN

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  On first call, call routines to set-up for Gear solver and 
c  set-up to do emissions here if that option is invoked
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      IF ( LFIRST ) THEN
         LFIRST = .FALSE.
         LOGDEV = INIT3( )

      IF ( .NOT. CELLVAR_ALLOC() ) THEN
         MSG = 'Failure allocating variables dependent on horizontal extents'
         CALL M3EXIT( PNAME, JDATE, JTIME, MSG, XSTAT1 )
         END IF

         CALL GRINIT
         CALL JSPARSE
         NOXYZ = MY_NCOLS * MY_NROWS * NLAYS
         MAOMV =  MWAIR / MWWAT

C..Set-up for emissions processing if necessary
         IF ( EMISCH ) THEN 

C...........get sigma layer definitions
!           X3FACE( 0 ) = VGLVS_GD( 1 )
!           DO LEV = 1, NLAYS
!              X3FACE( LEV ) = VGLVS_GD( LEV+1 )
!              X3MIDL( LEV ) = 0.5 * ( X3FACE( LEV ) + X3FACE( LEV-1 ) )
!           ENDDO


C...........set cell widths
            IF( GDTYP_GD .EQ. LATGRD3 ) THEN
               DX = DG2M * XCELL_GD         ! in m.
               DY = DG2M * YCELL_GD *
     &              COS( PI180 *( YORIG_GD + YCELL_GD * 
     &              FLOAT( NROWS ) ) )
            ELSE
               DX = XCELL_GD                ! in m
               DY = YCELL_GD                ! in m
            ENDIF 

C...........set molecular weight conversion factors for each species
            CONVFC = 1.0E+06 * MWAIR   
            AIRFC = CONVFC
!           DO ESP = 1, N_GC_EMIS
!              RELWT( ESP ) = CONVFC / GC_MOLWT( GC_EMIS_MAP( ESP ) )
!           ENDDO


C...........open the emissions file and check units
            IF( .NOT. OPEN3( EMIS_1, FSREAD3, PNAME ) ) THEN
               MSG = 'Could not open '// EMIS_1 // ' file'
               CALL M3EXIT( PNAME, JDATE, JTIME, MSG, XSTAT1 )
            ENDIF

            IF( .NOT. DESC3( EMIS_1 ) ) THEN
               MSG = 'Could not get '// EMIS_1 // ' file description'
               CALL M3EXIT( PNAME, JDATE, JTIME, MSG, XSTAT2 )
            ENDIF

            UNITSCK = UNITS3D( 1 )
            CALL UPCASE( UNITSCK )
            DO SPC = 1, N_GC_EMIS

               VAR = INDEX1( GC_EMIS( SPC ), NVARS3D, VNAME3D )
 
               IF ( VAR .NE. 0 ) THEN
                  UC_UNITS = UNITS3D( VAR )
                  CALL UPCASE( UC_UNITS )
                  IF( UC_UNITS .NE. UNITSCK ) THEN
                     MSG = 'Units not uniform on ' // EMIS_1
                     CALL M3EXIT( PNAME, JDATE, JTIME, MSG, XSTAT2 )
                  ENDIF
               ELSE
                  MSG = 'Emissions species ' // GC_EMIS( SPC )
     &                   // ' not found on ' // EMIS_1
                  CALL M3EXIT( PNAME, JDATE, JTIME, MSG, XSTAT2 )
               ENDIF

            ENDDO
 
!           IF( UNITSCK .EQ. 'G/S' ) THEN
!              CONVEM = 1.0E-03 * 60.0  ! (Kg/min)/(g/s)
!           ELSEIF ( UNITSCK .EQ. 'KG/HR' ) THEN
!              CONVEM = 1.0 / 60.0      ! (Kg/min)/(Kg/hr)
!           ELSE
!              MSG = 'Units incorrect on ' // EMIS_1
!              CALL M3EXIT( PNAME, JDATE, JTIME, MSG, XSTAT2 
!           ENDIF

            IF( UNITSCK .EQ. 'MOLES/S' ) THEN
               CONVEM = 1.0E-03 * 60.0  ! (Kg/min)/(g/s)
            ELSE
               MSG = 'Units incorrect on ' // EMIS_1
               CALL M3EXIT( PNAME, JDATE, JTIME, MSG, XSTAT2 )
            ENDIF


!           IF( EMISLYRS .NE. NLAYS3D ) THEN
!              MSG = 'Expected number of layers not in file'
!              CALL M3EXIT( PNAME, JDATE, JTIME, MSG, XSTAT2 )
!           ENDIF

            EMISLYRS = NLAYS3D

C...........Combine conversion factors and layer thicknesses:
            CONVFC = CONVEM / ( DX * DY )
            DO LEV = 1, NLAYS
               CONV( LEV ) = CONVFC
     &                     / ABS ( X3FACE_GD( LEV ) - X3FACE_GD( LEV-1 ) ) 
            END DO

            WRITE( LOGDEV, 92000 ) EMISLYRS, NLAYS

            CALL SUBHFILE ( EMIS_1, GXOFF, GYOFF,
     &                      STRTCOLEM1, ENDCOLEM1, STRTROWEM1, ENDROWEM1 )

         ENDIF   ! End if doing emissions

C...Initialize and report data
         DO NCELL = 1, BLKSIZE
            DO ISP = 1, N_GC_SPC
               EMBLK( NCELL, ISP ) = 0.0
            ENDDO
         ENDDO

         WRITE( LOGDEV, 92020 ) NOXYZ, BLKSIZE, NBLKS, BLKLEN( 1 ), 
     &                          BLKLEN( NBLKS )

         WRITE( LOGDEV, 92040 ) ERRMAX( 1 ), YLOW( 1 )

         CALL SUBHFILE ( MET_CRO_3D, GXOFF, GYOFF,
     &                   STRTCOLMC3, ENDCOLMC3, STRTROWMC3, ENDROWMC3 )

         ALLOCATE ( CONV( NLAYS ), STAT = ALLOCSTAT )
         IF ( ALLOCSTAT .NE. 0 ) THEN
            MSG = 'Failure allocating CONV'
            CALL M3EXIT ( PNAME, JDATE, JTIME, MSG, XSTAT1 )
            END IF

C:WTH Determine whether DEGRADE rountines are needed.

         IF( INDEX( MECHNAME, 'TX' ) .NE. 0 ) THEN
            CALL_DEG = .TRUE.
            WRITE( LOGDEV, * ) 'TX DEGRADE ROUTINES USED'
            WRITE( LOGDEV, * ) 'MECHNAME contains TX substring'
         END IF

C:WTH setting up degradation array

         CALL CGRID_MAP( NSPCSD, GC_STRT, AE_STRT, NR_STRT, TR_STRT )
         ALLOCATE( Y_DEGRADE( BLKSIZE, NSPCSD ) )

      ENDIF      ! First call

#ifdef sunws
C initialize run clock

      ERRSTAT = DTIME ( TARRAY )
      DRIVER_TIME = 0.0
      SOLVER_TIME = 0.0
#endif

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C  Start of integration driver after first call
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      IRUNC = IRUNC + 1
      NIRRCLS = 0

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C  Set date and time to center of time step, get necessary physical 
C  data, and get photolysis rates
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      MIDDATE = JDATE
      MIDTIME = JTIME
      ITMSTEP = TIME2SEC( TSTEP( 2 ) )
      CHEMSTEP = FLOAT( ITMSTEP ) / 60.0
      CALL NEXTIME( MIDDATE, MIDTIME, SEC2TIME( ITMSTEP / 2 ) )
 
C.. Get ambient temperature in K

      VNAME = 'TA' 
!     IF( .NOT. INTERP3( MET_CRO_3D, VNAME, PNAME, MIDDATE,
!    &                   MIDTIME, NCOLS * NROWS * NLAYS, TA ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VNAME, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MIDDATE, MIDTIME, TA ) ) THEN
         MSG = 'Could not read TA from MET_CRO_3D'
         CALL M3EXIT( PNAME, MIDDATE, MIDTIME, MSG, XSTAT1 )
      ENDIF
      
C.. Get specific humidity in Kg H2O / Kg air

      VNAME = 'QV'
!     IF( .NOT. INTERP3( MET_CRO_3D, VNAME, PNAME, MIDDATE,
!    &                   MIDTIME, NCOLS * NROWS * NLAYS, QV ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VNAME, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MIDDATE, MIDTIME, QV ) ) THEN
         MSG = 'Could not read QV from MET_CRO_3D'
         CALL M3EXIT( PNAME, MIDDATE, MIDTIME, MSG, XSTAT1 )
      ENDIF 
      
C.. Get density in Kg/m^3

      VNAME = 'DENS'
!     IF( .NOT. INTERP3( MET_CRO_3D, VNAME, PNAME, MIDDATE,
!    &                   MIDTIME, NCOLS * NROWS * NLAYS, DENS ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VNAME, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MIDDATE, MIDTIME, DENS ) ) THEN
         MSG = 'Could not read DENS from MET_CRO_3D'
         CALL M3EXIT( PNAME, JDATE, JTIME, MSG, XSTAT1 )
      ENDIF

C.. Get pressure in Pascals

      VNAME = 'PRES'
!     IF( .NOT. INTERP3( MET_CRO_3D, VNAME, PNAME, MIDDATE,
!    &                   MIDTIME, NCOLS * NROWS * NLAYS , PRES ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VNAME, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MIDDATE, MIDTIME, PRES ) ) THEN
         MSG = 'Could not read PRES from MET_CRO_3D'
         CALL M3EXIT ( PNAME, MIDDATE, MIDTIME, MSG, XSTAT1 )
      ENDIF
 
C.. Get photolysis rates in /min

      CALL PHOT ( MIDDATE, MIDTIME, JDATE, JTIME, NDARK, RJ )                    

C...Process emissions and air density if necessary 
      IF ( EMISCH ) THEN  

         VNAME = 'DENSA_J'
!        IF( .NOT. INTERP3( MET_CRO_3D, VNAME, PNAME, MIDDATE,
!    &                   MIDTIME, NCOLS * NROWS * NLAYS, DENSA_J ) ) THEN
         IF ( .NOT. INTERPX( MET_CRO_3D, VNAME, PNAME,
     &                      STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                       MIDDATE, MIDTIME, DENSA_J ) ) THEN
            MSG = 'Could not read DENSA_J from MET_CRO_3D'
            CALL M3EXIT ( PNAME, MIDDATE, MIDTIME, MSG, XSTAT1 )
         ENDIF

         DO ESP = 1, N_GC_EMIS

!           IF( .NOT. INTERP3( EMIS_1, GC_EMIS( ESP ), PNAME,
!    &                         MIDDATE, MIDTIME, NCOLS * NROWS * EMISLYRS,
!    &                         CHEMIS( 1, 1, 1, ESP ) ) ) THEN
            IF ( .NOT. INTERPX( EMIS_1, GC_EMIS( ESP ), PNAME,
     &                 STRTCOLEM1,ENDCOLEM1, STRTROWEM1,ENDROWEM1, 1,EMISLYRS,
     &                          MIDDATE, MIDTIME, CHEMIS( 1,1,1,ESP ) ) ) THEN
               MSG = 'Could not read  ' // GC_EMIS( ESP ) // ' from '
     &               // EMIS_1
               CALL M3EXIT( PNAME, MIDDATE, MIDTIME, MSG, XSTAT1 )
            ENDIF

         ENDDO

!        IF( LIPR ) CALL PA_UPDATE_EMIS( 'CHEM', CHEMIS, JDATE,
!    &                                    JTIME, TSTEP )

      ENDIF         ! (EMISCH)

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Set flag for reordering of cells and put cells in sequential  
c  order initially
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      LORDERING = .TRUE.
      IF( .NOT. LREORDER .OR. NBLKS.EQ.1 ) LORDERING = .FALSE.
      DO NCELL = 1, NOXYZ
         NORDCELL( NCELL ) = NCELL
      ENDDO

      IF( LPERFSMRY ) THEN
         ALLOCATE ( NSTPERF(    MXBLKS ), STAT = ALLOCSTAT )
         ALLOCATE ( MXORDPERF(  MXBLKS ), STAT = ALLOCSTAT )
         ALLOCATE ( NITERPERF(  MXBLKS ), STAT = ALLOCSTAT )
         ALLOCATE ( NSUBPERF(   MXBLKS ), STAT = ALLOCSTAT )
         ALLOCATE ( NPDPERF(    MXBLKS ), STAT = ALLOCSTAT )
         ALLOCATE ( NCFAILPERF( MXBLKS ), STAT = ALLOCSTAT )
         ALLOCATE ( NEFAILPERF( MXBLKS ), STAT = ALLOCSTAT )
         ALLOCATE ( IRSPERF(    MXBLKS ), STAT = ALLOCSTAT )
         ALLOCATE ( NBKUPS(     MXBLKS ), STAT = ALLOCSTAT )
         IF ( ALLOCSTAT .NE. 0 ) THEN
            MSG = 'Failure allocating NSTPERF, or MXORDPERF, or NITERPERF,'
     &          // ' or NSUBPERF, or NPDPERF, or NCFAILPERF, or NEFAILPERF,'
     &          // ' or IRSPERF, or NBKUPS'
            CALL M3EXIT ( PNAME, JDATE, JTIME, MSG, XSTAT1 )
            END IF
      END IF

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C  Top of loop over blocks. This loop will be done once if
C  no reordering, twice if reordering is required
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
  100 CONTINUE

      DO 500 BLK = 1, NBLKS
         BLKID = BLK
         NUMCELLS = BLKLEN( BLK )
         OFFSET = BLKCNO( BLK )
         IF( .NOT. LORDERING .AND. LIRR ) THEN
             LIRRBLK = .FALSE.
             CALL PA_IRR_CKBLK ( NUMCELLS, LIRRBLK, OFFSET,
     &                           CCOL, CROW, CLEV, NORDCELL, NIRRCLS,
     &                           IRRCELL )
             CALL PA_IRR_BLKSTRT( NUMCELLS )
         ENDIF
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C  Put the grid cell physical data in the block arrays, converting
C  pressure to atmospheres, water vapor to ppm, emissions to ppm/min 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         IF( EMISCH ) THEN
            DO NCELL = 1, NUMCELLS
               DO ISP = 1, ISCHANG( NCS )
                   EMBLK( NCELL, ISP ) = 0.0
               ENDDO
            ENDDO
         ENDIF

         DO NCELL = 1, NUMCELLS
            CELLNUM = NORDCELL( OFFSET + NCELL )
            COL = CCOL( CELLNUM )
            ROW = CROW( CELLNUM )
            LEV = CLEV( CELLNUM )
            BLKTEMP( NCELL )  = TA( COL, ROW, LEV )
            BLKDENS( NCELL )  = DENS( COL, ROW, LEV )
            BLKPRES( NCELL )  = PA2ATM * PRES( COL, ROW, LEV )
            BLKCH2O( NCELL )  = MAX ( QV( COL, ROW, LEV ) * MAOMV * 
     &                          1.0E+06, 0.0 )

            IF( EMISCH ) THEN 
               IF( LEV .LE. EMISLYRS ) THEN
                  DO ESP = 1, N_GC_EMIS
                     ISPNEW = IOLD2NEW( GC_EMIS_MAP( ESP ), NCS )
!                    EMBLK( NCELL, ISPNEW ) = CHEMIS( COL, ROW, LEV, ESP )
!    &                                      * GC_EMIS_FAC( ESP )               
!    &                                      * RELWT( ESP ) * CONV( LEV ) 
!    &                                      / DENSA_J( COL, ROW, LEV )
                     EMBLK( NCELL, ISPNEW ) = CHEMIS( COL, ROW, LEV, ESP )
     &                                      * GC_EMIS_FAC( ESP )                
     &                                      * AIRFC * CONV( LEV ) 
     &                                      / DENSA_J( COL, ROW, LEV )
                  ENDDO
               ENDIF
            ENDIF
          
         ENDDO

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C  Put the grid cell concentrations in the block arrays
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         DO ISP = 1, ISCHANG( NCS )
            ISPNEW = IOLD2NEW( ISP, NCS )
            DO NCELL = 1, NUMCELLS
               CELLNUM = NORDCELL( OFFSET + NCELL )
               COL = CCOL( CELLNUM )
               ROW = CROW( CELLNUM )
               LEV = CLEV( CELLNUM )
               IF( CONC( COL, ROW, LEV, ISP ) .GE. 1.1 * CONCMIN ) THEN
                  BLKCONC( NCELL, ISP ) = CONC( COL, ROW, LEV, ISP )
                  CNEW( NCELL, ISPNEW ) = BLKCONC( NCELL, ISP )
               ELSE   
                  BLKCONC( NCELL, ISP ) = ZBOUND
                  CNEW( NCELL, ISPNEW ) = ZBOUND
               ENDIF
            ENDDO                 
         ENDDO

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C   Get photolytic and thermal rate constants
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         LSUNLIGHT = .FALSE.

         DO NCELL = 1, NUMCELLS
            CELLNUM = NORDCELL( OFFSET + NCELL )
            COL = CCOL( CELLNUM )
            ROW = CROW( CELLNUM )
            LEV = CLEV( CELLNUM )
            DO NPH = 1, NPHOTAB
               RJBLK( NCELL, NPH ) = RJ( COL, ROW, LEV, NPH )
               IF( RJBLK( NCELL, NPH ) .GT. 0.0 ) LSUNLIGHT = .TRUE.
            ENDDO                         
         ENDDO
         
         CALL CALCKS( NPHOTAB, RJBLK )

         IF( LSUNLIGHT ) THEN
            HMAX = HMAXDAY( NCS )
            NCSP = NCS
         ELSE
            HMAX = HMAXNIT
            NCSP = NCS + 1
         ENDIF

C..WTH: Put concentrations into degradation array

         IF( CALL_DEG ) THEN
            Y_DEGRADE = 0.0D0
            DO ISP = 1, NSPCSD
               DO NCELL = 1, NUMCELLS
                  CELLNUM = NORDCELL( OFFSET + NCELL )
                  COL = CCOL( CELLNUM )
                  ROW = CROW( CELLNUM )
                  LEV = CLEV( CELLNUM )
                  Y_DEGRADE( NCELL, ISP ) = DBLE( CONC( COL, ROW, LEV, ISP ) )
               ENDDO                 
            ENDDO

C..initialize degradation routines
              
            CALL INIT_DEGRADE( Y_DEGRADE, BLKTEMP, BLKDENS, RJBLK, 
     &                         NUMCELLS,   JDATE,   JTIME, LOGDEV, BLKID )
  
         ENDIF

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C  If cells are not being reordered, do the outputs if needed and 
C  it is time
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         IF( .NOT. LORDERING ) THEN         
C..Output a concentrations for a single cell
            IF( LCELLCONC ) THEN
               LCONCOUT = .FALSE.
               CELLOUT = 0
               IF( IRUNC .GE. IRUNPRO1 .AND. IRUNC .LE. IRUNPRO2 ) THEN
                  DO NCELL = 1, NUMCELLS
                     CELLNUM = NORDCELL( OFFSET + NCELL )
                     COL = CCOL( CELLNUM )
                     ROW = CROW( CELLNUM )
                     LEV = CLEV( CELLNUM )
                     IF( COL.EQ.CCOLOUT .AND. ROW.EQ.CROWOUT .AND.
     &                        LEV.EQ.CLEVOUT ) THEN
                        LCONCOUT = .TRUE.
                        CELLOUT = NCELL
                        WRITE( IUNCOUT ) IRUNC, BLKID, CELLOUT, CCOLOUT,
     &                                   CROWOUT, CLEVOUT, IZERO,  
     &                                   RUNMIN, ( CNEW( CELLOUT,ISP ),
     &                                   ISP = 1, ISCHANG( NCS ) )
                     ENDIF
                  ENDDO
               ENDIF
            ENDIF
               
C..Output IC for a block                                    
            IF( LDUMPBLK .AND. IRUNC .EQ. IRUNBLK .AND. 
     &             BLKID .EQ. IBLKBLK ) THEN
               WRITE( IUNBIC ) NUMCELLS, CHEMSTEP
               WRITE( IUNBIC ) ( BLKTEMP( NCELL ),  NCELL = 1, NUMCELLS )
               WRITE( IUNBIC ) ( BLKPRES( NCELL ),  NCELL = 1, NUMCELLS )
               WRITE( IUNBIC ) ( BLKCH2O( NCELL ),  NCELL = 1, NUMCELLS )

               DO ISP = 1, ISCHANG( NCS )
                  WRITE( IUNBIC ) GC_SPC( ISP ), ( BLKCONC( NCELL, ISP ),
     &                            NCELL = 1, NUMCELLS )
               ENDDO

               DO NPH = 1, NMPHOT
                  IRXN = IPH( NPH, 1 )
                  WRITE( IUNBIC ) ( RK( NCELL, IRXN ), 
     &                              NCELL = 1, NUMCELLS )
               ENDDO

               MSG = 'Stopping in CHEM after dumping block IC'
               CALL M3EXIT( 'CHEM', JDATE, JTIME, MSG, XSTAT0 )
            ENDIF
            
C..Output IC for a cell            
            IF( LDUMPCELL .AND. IRUNC .EQ. IRUNCELL .AND.
     &            BLKID .EQ. IBLKCELL ) THEN 
               WRITE( IUNCIC, 93000 )

               DO ISP = 1, ISCHANG( NCS )
                  WRITE( IUNCIC, 93020 ) GC_SPC( ISP ),
     &                                BLKCONC( INUMCELL, ISP )
               ENDDO

               WRITE( IUNCIC,93040 ) BLKTEMP( INUMCELL ) 
               WRITE( IUNCIC,93060 ) BLKCH2O( INUMCELL )
               WRITE( IUNCIC,93080 ) BLKPRES( INUMCELL )

               DO NPH = 1, NMPHOT
                  IRXN = IPH( NPH, 1 )
                  WRITE( IUNCIC,93100 ) IRXN, RK( INUMCELL, IRXN )
               ENDDO

               MSG = 'Stopping in CHEM after dumping cell ic'
               CALL M3EXIT( 'CHEM', JDATE, JTIME, MSG, XSTAT0 )
            ENDIF
            
C..debug output            
            IF( LDEBUG .AND. IRUNC .EQ. IRUNBUG ) THEN
               ICPR = 0
               IBLKBUG = 0
               DO NCELL = 1, NUMCELLS
                  CELLNUM = NORDCELL( OFFSET + NCELL )
                  COL = CCOL( CELLNUM )
                  ROW = CROW( CELLNUM )
                  LEV = CLEV( CELLNUM )
                  IF( COL .EQ. DBGCOL .AND. ROW .EQ. DBGROW .AND.
     &               LEV .EQ. DBGLEV ) THEN
                     IBLKBUG = BLK
                     ICPR = NCELL
                     WRITE( IUNDBG, 93120 ) IRUNC, BLKID

                     DO NRX = 1, NRXNS
                        WRITE( IUNDBG, 93140 ) NRX, RK( ICPR, NRX )
                     ENDDO

                     WRITE( IUNDBG,93160 ) IRUNC, BLKID
                     NMID = NUMCELLS / 2
                     IF( NMID .LE. 0 ) NMID = 1
                     WRITE( IUNDBG,93360 ) NMID, NUMCELLS
               
                     DO ISP = 1, ISCHANG( NCS )
                        ISPOLD = INEW2OLD( ISP,NCS )
                        WRITE( IUNDBG, 93380 ) ISP, GC_SPC( ISPOLD ),
     &                                   CNEW( 1,ISP ), CNEW( NMID,ISP ),
     &                                   CNEW( NUMCELLS, ISP )
                     ENDDO
               
                     WRITE( IUNDBG, 93200 ) ISCHANG( NCS ) + 1, CONCOFM
                     WRITE( IUNDBG, 93220 ) ISCHANG( NCS ) + 2, 0.2095*CONCOFM
                     WRITE( IUNDBG, 93240 ) ISCHANG( NCS ) + 3, 0.7808*CONCOFM
                     WRITE( IUNDBG, 93260 ) ISCHANG( NCS ) + 4, BLKCH2O( 1 ),
     &                                      BLKCH2O( NMID ), BLKCH2O( NUMCELLS )
                     WRITE( IUNDBG, 93280 ) BLKTEMP( 1 ), BLKTEMP( NMID ),
     &                                      BLKTEMP( NUMCELLS )
                     WRITE( IUNDBG, 93300 ) BLKPRES( 1 ), BLKPRES( NMID ),
     &                                      BLKPRES( NUMCELLS ) 
                  ENDIF
               ENDDO
            ENDIF
         ENDIF
         
         IF( LTRACE .AND. IRUNC .GE. IRUNTRC1 .AND. IRUNC .LE. IRUNTRC2
     &              .AND. BLKID .EQ. IBLKTRC ) THEN 
            LTRCOUT = .TRUE.
         ELSE
            LTRCOUT = .FALSE.
         ENDIF 

#ifdef sunws
         ERRSTAT = DTIME ( TARRAY )
         DRIVER_TIME = DRIVER_TIME + TARRAY( 1 )
#endif

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C   Call Gear solver for the integration interval
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         CALL SMVGEAR( IRUNC, JDATE, JTIME, CHEMSTEP, LIRRBLK, NIRRCLS,
     &                 IRRCELL )
        
#ifdef sunws
         ERRSTAT = DTIME ( TARRAY )
         SOLVER_TIME = SOLVER_TIME + TARRAY( 1 )
#endif

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C  If not ordering cells, save performance statistics, do debug output
C  if requested, and store updated concentrations.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         IF( .NOT. LORDERING ) THEN
!           print *,'finished irun = ', IRUNC, ' block ', BLKID,
!    &               ' nsteps= ', NSTEPS, MXORDUSED, NUMNEWT, NSUBFUN,
!    &               NPDERIV, NCFAIL, NEFAIL, IRSTART, NUMBKUPS,
!    &               LIRRBLK, NIRRCLS
            IF( LPERFSMRY ) THEN
               NSTPERF(    BLK ) = NSTEPS
               MXORDPERF(  BLK ) = MXORDUSED
               NITERPERF(  BLK ) = NUMNEWT
               NSUBPERF(   BLK ) = NSUBFUN
               NPDPERF(    BLK ) = NPDERIV
               NCFAILPERF( BLK ) = NCFAIL
               NEFAILPERF( BLK ) = NEFAIL
               IRSPERF(    BLK ) = IRSTART
               NBKUPS(     BLK ) = NUMBKUPS
            ENDIF
C..debug output
            IF( LDEBUG .AND. IRUNC .EQ. IRUNBUG .AND.
     &              BLK .EQ. IBLKBUG ) THEN
               WRITE( IUNDBG, 93320 ) IRUNC, ICPR
               DO ISP = 1, ISCHANG( NCS )
                  ISPNEW = IOLD2NEW( ISP, NCS )
                  WRITE( IUNDBG, 93340 ) ISP, GC_SPC( ISP ),
     &                                   CNEW( ICPR, ISPNEW )
               ENDDO

               NMID = NUMCELLS / 2
               IF( NMID.LE.0 ) NMID = 1
               WRITE( IUNDBG, 93360 ) NMID, NUMCELLS
               DO ISP = 1, ISCHANG( NCS )
                  ISPOLD  = INEW2OLD( ISP, NCS )
                  WRITE( IUNDBG, 93380 ) ISP, GC_SPC( ISPOLD ),
     &                                   CNEW( 1,ISP ), 
     &                                   CNEW( NMID, ISP ),
     &                                   CNEW( NUMCELLS, ISP )
               ENDDO
            ENDIF

C..Update concentrations
           DO ISP = 1, ISCHANG( NCS )
               ISPOLD  = INEW2OLD( ISP, NCS )
               DO NCELL = 1, NUMCELLS
                  CELLNUM = NORDCELL( OFFSET + NCELL )
                  ROW = CROW( CELLNUM )
                  COL = CCOL( CELLNUM )
                  LEV = CLEV( CELLNUM )
                  CONC( COL, ROW, LEV, ISPOLD ) = CNEW( NCELL, ISP ) 
               ENDDO
            ENDDO

            IF( CALL_DEG ) THEN

C  Update concentrations

               DO ISP = 1, ISCHANG( NCS )
                  ISPOLD  = INEW2OLD( ISP, NCS )
                  DO NCELL = 1, NUMCELLS
                     Y_DEGRADE( NCELL, ISPOLD ) = CNEW( NCELL, ISP )
                  ENDDO
               ENDDO

C  Update CGRID based on the degradation routines

               CALL FINAL_DEGRADE( Y_DEGRADE )
               DO ISP = NR_STRT, ( TR_STRT - 1 )
                  DO NCELL = 1, NUMCELLS
                     CELLNUM = NORDCELL( OFFSET + NCELL )
                     ROW = CROW( CELLNUM )
                     COL = CCOL( CELLNUM )
                     LEV = CLEV( CELLNUM )
                    CONC( COL, ROW, LEV, ISP ) = Y_DEGRADE( NCELL, ISP )
                  ENDDO
               ENDDO
            ENDIF

            IF( LIRRBLK ) CALL PA_IRR_BLKENDC ( OFFSET, CCOL, CROW, CLEV,
     &                                          NORDCELL, NIRRCLS, IRRCELL )

         ENDIF

  500 CONTINUE

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C  End of block loop; reorder cells if necessary and go back do the  
C  block loop again.  Taken from Jacobson 1994.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      IF( LORDERING ) THEN
         LORDERING = .FALSE.     
         LVAL = NOXYZ * 0.5 + 1
         IRVAL = NOXYZ
  600    IF( LVAL .GT. 1 ) THEN
            LVAL = LVAL - 1
            VALLOW = ERRMX2( LVAL )
            JREORD = NORDCELL( LVAL )
         ELSE
            VALLOW = ERRMX2( IRVAL )
            JREORD = NORDCELL( IRVAL )
            ERRMX2( IRVAL ) = ERRMX2( 1 )
            NORDCELL( IRVAL ) = NORDCELL( 1 )
            IRVAL = IRVAL - 1
            IF( IRVAL.EQ.1 ) THEN
               ERRMX2( IRVAL ) = VALLOW
               NORDCELL( IRVAL ) = JREORD
               GO TO 100
            ENDIF
         ENDIF
         IPAR = LVAL
         JPAR = LVAL + LVAL
  650    IF( JPAR .LE. IRVAL ) THEN
            IF( JPAR .LT. IRVAL ) THEN
               IF( ERRMX2( JPAR ) .LT. ERRMX2( JPAR + 1 ) )
     &                 JPAR = JPAR + 1
            ENDIF
            IF( VALLOW .LT. ERRMX2( JPAR )) THEN
               ERRMX2( IPAR ) = ERRMX2( JPAR )
               NORDCELL( IPAR ) = NORDCELL( JPAR )
               IPAR = JPAR
               JPAR = JPAR + JPAR
            ELSE
               JPAR = IRVAL + 1
            ENDIF
            GO TO 650
         ENDIF
         ERRMX2( IPAR ) = VALLOW
         NORDCELL( IPAR ) = JREORD
         GO TO 600
      ENDIF
       
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C  Output performance statistics if required and return
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      IF( LPERFSMRY ) THEN
         WRITE( IUNPERF ) IRUNC, NBLKS, JTIME, CHEMSTEP
         WRITE( IUNPERF ) ( NSTPERF(    BLK ), BLK = 1, NBLKS )
         WRITE( IUNPERF ) ( MXORDPERF(  BLK ), BLK = 1, NBLKS )
         WRITE( IUNPERF ) ( NITERPERF(  BLK ), BLK = 1, NBLKS )
         WRITE( IUNPERF ) ( NSUBPERF(   BLK ), BLK = 1, NBLKS )
         WRITE( IUNPERF ) ( NPDPERF(    BLK ), BLK = 1, NBLKS )
         WRITE( IUNPERF ) ( NCFAILPERF( BLK ), BLK = 1, NBLKS )    
         WRITE( IUNPERF ) ( NEFAILPERF( BLK ), BLK = 1, NBLKS )
         WRITE( IUNPERF ) ( IRSPERF(    BLK ), BLK = 1, NBLKS )
         WRITE( IUNPERF ) ( NBKUPS(     BLK ), BLK = 1, NBLKS )
         DEALLOCATE ( NSTPERF )
         DEALLOCATE ( MXORDPERF )
         DEALLOCATE ( NITERPERF )
         DEALLOCATE ( NSUBPERF )
         DEALLOCATE ( NPDPERF )
         DEALLOCATE ( NCFAILPERF )
         DEALLOCATE ( NEFAILPERF )
         DEALLOCATE ( IRSPERF )
         DEALLOCATE ( NBKUPS )
      ENDIF

#ifdef sunws
      ERRSTAT = DTIME( TARRAY )
      DRIVER_TIME = DRIVER_TIME + TARRAY( 1 )

      WRITE( LOGDEV, 93400 ), DRIVER_TIME, SOLVER_TIME
93400 FORMAT( / 10X, 'Timing Statistics in Chemistry ...'
     &        / 10X, 'Driver time for this step:', 1PG13.5
     &        / 10X, 'Solver time for this step:', 1PG13.5 )
#endif

      RETURN
      
C*********************** FORMAT STATEMENTS ****************************
92000 FORMAT( / 10X, 'Emissions Processing in Chemistry ...'
     &        / 10X, 'Number of Emissions Layers:         ', I3
     &        / 10X, 'out of total Number of Model Layers:', I3 )
92020 FORMAT( / 10X, 'Chemistry Solver Blocking Parameters ... ',
     &        / 10X, 'Domain Size (number of cells):             ', I10
     &        / 10X, 'Dimensioning Block Size (number of cells): ', I10
     &        / 10X, 'Number of Blocks:        ', I10
     &        / 10X, 'Size of General Blocks:  ', I10
     &        / 10X, 'Size of Last Block:      ', I10 )
92040 FORMAT( / 10X, 'Chemistry Solver Error Control Parameters ...',
     &        / 10X, 'RTOL : ', 1PE12.3,
     &        / 10X, 'ATOL : ', 1PE12.3, ' ppm' )

93000 FORMAT(   'units' )
93020 FORMAT(   A4, 1X, 1PE15.6 )
93040 FORMAT(   'TEMP', 1X, 1PE15.6 )
93060 FORMAT(   'H2O ', 1X, 1PE15.6 )
93080 FORMAT(   'PRES', 1X, 1PE15.6 )
93100 FORMAT(   I3, 1X, 1PE15.6 )
93120 FORMAT(   1X, 'Rate constants at start of irun=', I4, 
     &              ' block=', I4 )
93140 FORMAT(   1X, 'n= ', I3, ' k=', 1PE20.8 )
93160 FORMAT(  /1X, 'Species concentrations at start of irun=', I4,
     &              ' for block=',I4)
93180 FORMAT(   1X, 'C(0)= ', I3, 2X, A4, 2x, 3( 1PE20.10 ) )
93200 FORMAT(   1X, 'C(0)= ', I3, 2X, 'M   ', 2X, 1PE20.10 )  
93220 FORMAT(   1X, 'C(0)= ', I3, 2X, 'O2  ', 2X, 1PE20.10 ) 
93240 FORMAT(   1X, 'C(0)= ', I3, 2X, 'N2  ', 2X, 1PE20.10 ) 
93260 FORMAT(   1X, 'C(0)= ', I3, 2X, 'H2O ', 2X, 3( 1PE20.10 ) )
93280 FORMAT(   1X, 'TEMP (K)   =   ', 3( 1PE20.10 ) )
93300 FORMAT(   1X, 'PRESS(ATM) =   ', 3( 1PE20.10 ) )
93320 FORMAT(  /1X, 'Species concentrations at end of irun=', I4,
     &              ' Cell=', I5 )
93340 FORMAT(   1x, 'C(end)= ', I3, 2x, A4, 2x, 1PE20.8)
93360 FORMAT( //1X, 'Concs for cell 1, cell ',I3,' and cell ',I3 )
93380 FORMAT(   1X, 'C(E)= ',I3, 2X, A4, 2X, 3( 1PE20.10 ) )
      END
                            

@


1.1.1.1
log
@CMAQv4_5_1 release
@
text
@@
